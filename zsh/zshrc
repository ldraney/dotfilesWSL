export PATH="$HOME/.local/bin:$PATH"

set -o autopushd
#
# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
#if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  #source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
#fi

ZSH_THEME="cloud"
#ZSH_THEME="powerlevel10k/powerlevel10k"


# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
 HYPHEN_INSENSITIVE="true"

# Uncomment the following line to disable auto-setting terminal title.
 DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
 COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"
export NVM_LAZY_LOAD=true
export NVM_COMPLETION=true

plugins=(
	#aliases
    vi-mode
    zsh-syntax-highlighting 
    zsh-autosuggestions
	#pyenv
	wd
	cd-gitroot
	#aws
    #docker
    #docker-compose
	#git 
	#tmux
    #python
    #zsh-navigation-tools
    #salt
    #git
    #fd
    #tmuxinator
	#terraform
	#npm
)
#
# vi mode
#bindkey -v

# Yank to the system clipboard
# may need to change for Windows
function vi-yank-xclip {
	zle vi-yank
	echo "$CUTBUFFER" | /mnt/c/windows/system32/clip.exe
}
zle -N vi-yank-xclip
bindkey -M vicmd 'y' vi-yank-xclip
#zle vi-yank

#for tmuxinator, use this: 
# wget https://raw.githubusercontent.com/tmuxinator/tmuxinator/master/completion/tmuxinator.zsh -O /usr/local/share/zsh/site-functions/_tmuxinator
source $ZSH/oh-my-zsh.sh

# for npm, should have been installed with teh bootstrap.sh
source ~/.nvm/nvm.sh

#if tmux isn't running, run it:
if tmux info &> /dev/null; then 
  #echo Tmux is running. Enjoy!
  pwd
  echo "\"autocomplete()\" for terraform, aws, github cli, nvm, docker"
else
	#tmux attach-session -t default
	tmux new-session -s default || tmux attach-session -t default
fi

#fix the tmux autocomplete color for Zsh
export TERM=xterm-256color 

#aliases
#alias gq='$HOME/.customCommands/gitScript.sh'
alias setLoginBackground='$HOME/.customCommands/setLoginBackground'
alias gansPre='$HOME/.customCommands/gansPre.sh'
alias gans='$HOME/.customCommands/gitAns.sh'
alias gqAll='$HOME/.customCommands/gqAll.sh'
alias lt='ls -lt --color=always'
alias ltt='ls -lt --color=always | head'
#alias lt='echo "hi mom"'
alias cdg=cd-gitroot
alias k=kubectl
alias ter=terraform
alias vim=nvim
alias cheat='cheat -e'

cdt (){
  cd-gitroot
  cd ../
}

findfile() {
	find .  -name $1
	find . -type f -name "*$1*"
}
findwordexact() {
	find . -exec grep -l -s $1 {} \;
}
findword() {
	find . -exec grep -i -l -s $1 {} \;
}
findwordToFile(){
	findword $1 > /tmp/$1.txt
}

findSecondword(){
	#findSecondWord [first-word] [second-word]
	# must run findwordToFile first
	#first input is the word, second input is the output file from findwordToFile
	xargs -o -n 1 grep -i -l -s $2 < /tmp/$1.txt
}
findSecondwordToFile(){
	#first input is the word, second input is the files from findwordToFile
	cat /tmp/$1.txt | xargs -o -n 1 grep -i -l -s $2 > /tmp/$2.txt
}

edit() {
	nvim < /tmp/$1.txt
}
check() {
	#xargs -o -n 1 nvim < /tmp/$1.txt
	xargs -o -n 1 -I {} nvim "{}" < /tmp/$1.txt #needed so that filenames with special characters and spaces were read correctly
	#while IFS= read -r line; do nvim -- "$line"; done < /tmp/$1.txt
}

#list only file names in current directory
findcur(){
	find ./ -printf "%f\n"
}

my_cheats()
{
  cheats=("${(f)$(cheat -l -t personal | tail -n +2 | cut -d' ' -f1)}")
  _describe -t cheats 'cheats' cheats
}

#add a new cheat file
#I releazed this isn't necessary, since any community file you edit is automatically moved to personal! and both coummnity and personal are already in my repo
#cheatAdd(){
#vim /home/ldraney/github/dotfilesWSL/cheat/cheatsheets/personal/$1.md
#}

#```zsh
#ZSH_HIGHLIGHT_STYLES[comment]='bg=red'
#```
#zle_highlight=(none)
#ZSH_HIGHLIGHT_STYLES[root]='bg=red'
#: ${ZSH_HIGHLIGHT_STYLES[comment]:='bg=purple'}
#ZSH_HIGHLIGHT_HIGHLIGHTERS+=(acme)

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
#[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

#make sure user is in docker group!
#DOESNT WORK IS ENDLESS LOOP!
#newgrp docker
#

##gcloud autocomplete
#source $HOME/github/dotfilesWSL/google-cloud-sdk/completion.zsh.inc
#source $HOME/github/dotfilesWSL/google-cloud-sdk/path.zsh.inc
#source $HOME/google-cloud-sdk/completion.zsh.inc
#source $HOME/google-cloud-sdk/path.zsh.inc
#
#kubectl autocomplete
#source <(kubectl completion zsh)

#awscli2 autocomplete
#autoload bashcompinit && bashcompinit
#autoload -Uz compinit && compinit

#docker autocomplete
#fpath=(~/.zsh/completion $fpath)
#autoload -Uz compinit && compinit -i
##
##terraform autocomplete command is run on bootstrap.sh:
##terraform -install-autocomplete
##produces something like this:
##complete -o nospace -C /nix/store/q3q9mbv4w48hkwrpkbqvfnbn6r8v1967-terraform-1.3.3/bin/terraform terraform

##for terraform autocomplete
#autoload -U +X bashcompinit && bashcompinit
#complete -o nospace -C $(whereis terraform | cut -c 12-) terraform

##aws autocomplete
#complete -C '/usr/local/bin/aws_completer' aws

## github cli autocomplete
## https://www.ajfriesen.com/github-cli-auto-completion-with-oh-my-zsh/
#autoload -U compinit
#compinit -i

##what is nvm?
#export NVM_DIR="$HOME/.nvm"
#[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
#[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

#complete -o nospace -C /home/ldraney/.tfenv/versions/1.1.3/terraform terraform

function autocomplete() {
  fpath=(~/.zsh/completion $fpath)
  autoload -Uz compinit && compinit -i

  # for terraform autocomplete
  autoload -U +X bashcompinit && bashcompinit
  complete -o nospace -C $(whereis terraform | cut -c 12-) terraform

  # aws autocomplete
  complete -C '/usr/local/bin/aws_completer' aws

  # github cli autocomplete
  autoload -U compinit
  compinit -i

  # nvm
  export NVM_DIR="$HOME/.nvm"
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"

  complete -o nospace -C /home/ldraney/.tfenv/versions/1.1.3/terraform terraform
}

function retry-profiler(){
  docker-compose -f ci/docker-compose-local.yml down
  docker image rm ci_datadog-agent
  docker image rm notification_api
  docker-compose -f ci/docker-compose-local.yml build
  docker-compose -f ci/docker-compose-local.yml up
}

function git-worktree-add() {
  branch_name=$1
  repo=$2
  wd $repo
  git fetch origin
  git worktree add master
  cd master
  git pull origin master
  wd $repo
  git worktree add $branch_name
  cd $branch_name
  git pull origin $branch_name
  echo "ignore the above error if you are creating a new branch"
  git push --set-upstream origin $branch_name
  if [ "$repo" = "noti" ]; then
	wd-new-branch $branch_name oddball/notification-api
  elif [ "$repo" = "qa" ]; then
	wd-new-branch $branch_name oddball/notification-api-qa
  elif [ "$repo" = "infra" ]; then
	wd-new-branch $branch_name oddball/vanotify-infra
  elif [ "$repo" = "helps" ]; then
	wd-new-branch $branch_name github/oddball_helps
  elif [ "$repo" = "dia" ]; then
	wd-new-branch $branch_name github/DevOpsDialecticAI
  elif [ "$repo" = "dia-infra" ]; then
	wd-new-branch $branch_name github/DevOpsDialecticAI-infra
  fi
}

function wd-new-branch() {
  branch_name=$1
  branch_number=$(echo "$branch_name" | awk -F'-' '{print $1}')
  directory=$2

  cd ~/$directory/$branch_name
  wd add --force $branch_number
  wd $branch_number
}

#Need to fix worktree variable awk
#function git-worktree-update() {
  #git fetch origin master
  ## Get the list of worktrees
  #worktrees=$(git worktree list --porcelain | grep 'worktree' | awk '{print $2}')

  ## Loop over each worktree and update it
  #for worktree in $worktrees
  #do
	  #echo "Updating worktree $worktree"
	  ## Navigate to the worktree directory
	  #cd $worktree
	  ## Checkout master branch
	  #git checkout master
	  ## Pull the latest changes
	  #git pull origin master
	  ## Navigate back to the original directory
	  #cd -
  #done
#}

function git-delete-worktree() {
  branch_name=$1
  git push origin --delete $branch_name
  git worktree remove $branch_name
  git branch -D $branch_name
}

function git-rename-branch() {
  if [ $# -ne 2 ]; then
    echo "Usage: git-rename-branch <old-branch-name> <new-branch-name>"
    return 1
  fi

  local old_branch=$1
  local new_branch=$2
  local repo=$3

  # Rename the local branch
  git branch -m "$old_branch" "$new_branch"

  # Delete the old branch on remote
  git push origin --delete "$old_branch"

  # Push the new branch and reset the upstream branch
  git push origin -u "$new_branch"

  git worktree remove "$old_branch"
  git-worktree-add "$new_branch" $repo
}

function create-ticket() {
    # Define the valid options
    local options=("bug" "deployment" "spike" "story")

    # Check if the input type is a valid option
    if [[ " ${options[*]} " != *" $1 "* ]]; then
        echo "Invalid type. Please choose from: ${options[*]}"
        return
    fi

    # Navigate to the directory
    wd issue_templates

    # Update the repository
    git pull

    # Prepare the template name
    local template_name="notify-$1-template.md"

    # Prepare the destination file path
    local destination="/tmp/$2.md"

    # Check if the template file exists
    if [[ -f "$template_name" ]]; then
        # Copy the template to the temporary directory
        cp "${template_name}" "${destination}"

        # Edit the copied template
        vim "${destination}"
    else
        echo "Template file ${template_name} does not exist."
    fi
}

function start-pr() {

    # Navigate to the desired directory
    wd pr-template

    # Update the repository
    git pull

    # Prepare the PR template name
    local template_name="pull-request-draft.md"

    # Prepare the destination file path
    local destination="/tmp/$1.md"

    # Check if the PR template file exists
    if [[ -f "$template_name" ]]; then
        # Copy the PR template to the temporary directory
        cp "${template_name}" "${destination}"

        # Edit the copied PR template
        vim "${destination}"
    else
        echo "PR template file ${template_name} does not exist."
    fi
}

#function create-pr() {

#}

function gq() {
  echo "Fetching updates from the remote repository..." &&
  git fetch &&

  echo "Merging changes (if any) from the master branch into the current branch..." &&
  git merge master &&

  echo "Pushing master changes (if any) to the current remote branch..." &&
  git push &&

  echo "Pulling updates from the remote repository and merging them into the current branch..." &&
  git pull &&

  echo "Adding all changes to the staging area..." &&
  git add -A &&

  echo "Committing the changes with the provided message..." &&
  git commit -m "$1" &&

  echo "Pushing the committed changes to the remote repository..." &&
  git push
}

function browser() {
  /mnt/c/Program\ Files\ \(x86\)/Microsoft/Edge/Application/msedge.exe "$1"
}

function open_zenhub_issue() {
  local github_url="$1"
  local repo="$2"
  if [ "$repo" = "noti" ]; then
	local repo="notification-api"
  elif [ "$repo" = "qa" ]; then
	local repo="notification-api-qa"
  elif [ "$repo" = "infra" ]; then
	local repo="vanotify-infra"
  fi

  local issue_number=$(echo "$github_url" | grep -oE '[0-9]+$')
  local zenhub_url="https://app.zenhub.com/workspaces/va-notify-620d21369d810a00146ed9c8/issues/gh/department-of-veterans-affairs/$repo/$issue_number"
  browser "$zenhub_url"
}

function pr_view() {
  local repo=$1
  local branch=$2
  wd $repo $branch

  if [ "$repo" = "noti" ]; then
	local repo="notification-api"
  elif [ "$repo" = "qa" ]; then
	local repo="notification-api-qa"
  elif [ "$repo" = "infra" ]; then
	local repo="vanotify-infra"
  fi

  pr_number=$(gh pr view $branch | grep -m1 -oE 'https://github.com/[^ ]*' | grep -oE '[0-9]+$')

  browser "https://github.com/department-of-veterans-affairs/$repo/pull/$pr_number"
}

function pr_merge() {
  local repo=$1
  local branch=$2
  pr_number=$(gh pr view $branch | grep -m1 -oE 'https://github.com/[^ ]*' | grep -oE '[0-9]+$')
  echo "merging PR: $pr_number"

  wd $repo master
  git pull
  git fetch origin
  gh pr merge 125 --squash
  git push origin master
}
